
# Week2_Embedded C Langguage
 - 이번주에는 임베디드 분야에 특화되어 C언어를 실습합니다.
 - 교보재로는 MDS2450 보드를 사용합니다.
 - Processor : SAMSUNG S3C2450
 - C언어도 추가적인 학습을 진행합니다.
 - 강사님의 추천 : 망고스토리 보드 , 한빛미디어 해마 책, BJ 알고리즘, 알고리즘 하루에 한문제씩 꼭 풀어봐라 아이들아 
## Index
1. 
2. 

## 개발자들 위한 Tip
 > 자기관리에 관하여
 1. 대부분의 시간을 컴퓨터 앞에 않아 머리쓰는일을 하므로, 운동이 부족하다.
 2. 고로 건강을 위한 육체단련할 시간이 부족하다.
 3. 따라서 Active한 취미를 추천한다(신체활동이 수반되는 취미활동을 권장하심)
 4. 먹고 스트레스받는게 일상다반사이므로, 더 먹게되고 이는 곧 체중증가를 의미한다.
 5. 배만 나오고 팔다리가 얇아지므로 되도록 운동을 하자
 > 디버깅에 관하여
 1. 디버깅은 숙명이다 회사에서의 시간중 90%는 디버깅중일것이다. 여기에 스트레스를 받으면 힘들것이다. (변하던가, 그만두던가)
 2. 디버깅을 더 빨리 더 잘 하는 사람을 논리적이라고 하며, 대부분의 경우에 개발자의 최고 덕목으로 인정받는다.
 
=======================================================================

## MDS2450 보드로 실습환경 셋팅하는법 
 >MDS2450 보드를 실습하기 위한 구축은 5단계로 나뉩니다.
 1. VM(가상머신 환경 구축) : 호스트, 게스트간 공유폴더 설정
 2. Teraterm(Serial 터미널 프로그램) 설치 : RS232및 USART 를 이용, Bootloader, Prompt 환경 적응
 3. Linux(게스트, Ubuntu 10)에서 컴파일 환경 셋팅 : Make, ARM컴파일러 설치
 4. TFTP 를 활용한 xx.bin 파일 전송(binary)
 5. MDS2450 보드에서의 동작 확인 
 - 디테일하게 알아야할것이 많지만, 대부분의 임베디드 시스템 개발에 공통적으로 적용되는 단계만을 간략히 적었습니다.


## 환경 설정간 알아야 할 요소들
 >크로스 컴파일 환경(Host PC) : Arch: x86 , OS: Ubuntu10
- 명령어 : pwd,cd (cd /:루트로 이동) 
- root 는 수퍼유저임
- FTP : file transfer protocol : 개발환경 PC에서 Target 보드로 컴파일 완료된 파일을 전송할 때 쓰는 규격임 ->> IP Addresss + File name만 가지고 처리함
- 작업장 특성상 전송을 편하기 위해서 USB to LAN 케이블을 사용하며, 이를 윈도우즈에서 리눅스로 제어권 권한 변경을 해 주어야 함
- C클래스의 마스크까지 같아야 하므로 Subnet Mask는 255.255.255
- .Tar확장자 : 묶음 파일
- .bz : 리눅스에서의 압축파일
- .Tar.bz 풀기 명령어 : Tar xvjf (filename)
- .zip 압축파일 풀기 명령어 unzip (filename)
- GCC는 엄밀한 의미에서의 컴파일러가 아니며, 정확하게는 Toolchain입니다.
- .ld파일은 링커 스크립트이며, 링커가 오브젝트 파일들을 링크해 줄때 참조하는 문서입니다.
- GCC에서의 크로스 컴파일러들은 "(아키텍쳐명)-(접두어)-###" 과 같은 규칙을 갖습니다. EX)ARM-enbi-###
- 리눅스에서의 환경변수 셋팅을 위한 명령어 : gedit environment / vi environment
- 컴파일을 위한 명령어 : make / make clean
- (내가 실수한 부분) 강사님이 루트밑에 만들어주세요~ 를 "/"위치에 생성함. 강사님의 의도는 root라는 폴더를 만들어서 "/root/" 하위에 압축해제를 말씀하심 ->> 환경변수부터 링커까지 모든 생각하는 자동화기능이 동작하지 않는 상태가 될 수 있습니다.
- Makefile과 make란? -> 리눅스에서 컴파일을 쉽게 해줄 수 있는 도구(유틸리티)
- make 인스톨 이후 make 유틸리티 프로그램이 Makefile을 돌려주는것이다.
- 주의점 : 같은 공간에 Makefile과 makefile이 공존하는 경우 시스템이 어떤파일을 참조할지 모르는것이므로 둘중 하나의 파일만을 생성할것
### !!! Makefile 와 Make에 대하여 추가 공부 필요함

 > 타겟보드 (Target) : Arch: ARM , Vender: Samsung , AP: S3C2450MDS2450 
- printenv명령어 : 프롬프트의 설정된 기본값들을 화면에 표시함
- tftp 30000000 MDS2450.bin : tftp포멧으로 전송 함
- set serverip 192.168.20.90 : 서버 IP Addr 고정
- set ipaddr 192.168.X.X : 클라이언트 IP Addr 고정
- saveenv : 모든 Prompt 명령어를 NAND FLASH에 저장
- 30000000(0은 7개) 의 의미 : 다운로드받은 보드의 프로그램 시작 지점 -> C언어에서는 Main()이 시작지점이지만, 임베디드에서는 .s 확장자의 스타트업 코드가 시작 지점임. 스타트업 코드에서 Main()으로 Jump함 -> (Jump동사의 주어는 Program Counter)
- 다운로드 자동화(Makefile & prompt 등록) :
 :"set bootcmd "tftp 30000000 MDS2450.bin;go 30000000"  ->>   "saveenv"
 
 =======================================================================

## C언어 One point Lesson
> C언어의 컴파일 과정
- Main.c ==(1단변신)==>> Main.i ==(2단변신)==>> Main.s ==(3단변신)==>> Main.o
- 1단변신 : 전처리기, 프리프로세서가 프리프로세싱 하는 과정
- 2단변신 : C컴파일러가 컴파일 하는 과정
- 3단변신 : 어셈블러가 어셈블하는 과정
- 이후: 링커가 링커스크립트를 참조하여 XX.bin 파일을 생성해낸다.
- ciso-bi : 모르면 외우자 씨소-비
- 오브젝트 파일은 2진수로 된 명령과 데이터로 구성되어있다. 
- 디스어셈블 코드에서 .text 는 인스트럭션 명령어임
- 링커 스크립트 : 링커가 동작해 함수와 파일들의 번지수를 매겨주고, 오브젝트 파일들을 연결 해 주는 아이

> 상수와 변수 
- 함수의 이름은 주소이며 따라서 상수이다.
- 매개변수와 지역변수는 스텍영역에 생성되며 초기화해주지 않으면 쓰래기값이 들어있다.
- 자료구조에서 Queue는  FIFO이며 Stack은 LIFO이다.
- 변수란 데이터를 저장하기 위해 예약된 공간이며 변수명을 통해서 접근이 가능하다.
- 변수의 접근에는 두가지가 있다. Load 와 Store (ARM 아키텍쳐 기준)

> 음수 표현방식 3가지가 있다
- 부호화 절대치 방식 // 특징 : +0과 -0 음의 영이 존재함
- 1의보수 방식 // 특징 : ~
- 2의 보수 방식 // 특징 : 대부분 사용중인 방식
- 사실 콤퓨터에게는 음수란 없다. 인간의 눈으로 보기에만 음수가 존재할 뿐 이다.

> 정수형 데이터의 승격
- Unsigned int 에서는 승격시 0으로 채워진다.
- signed int 에서는 승격시 음수라면 1로, 양수라면 0으로 채워진다.

> 지역변수
- {}블록 내에서만 유효한 변수, 다른 함수나 블록에서는 사용 불가능
- Stack에 저장하는 아이들은 초기화하지 않으면 쓰래기값

> 전역변수
- 프로그램 전체에 유효한 변수
- 모든 함수나 블록 내에서 사용 가능
- Runtime 시에 메모리 상주, 프로그램 종료시 소멸

> C언어에서 메모리 공간의 4가지 분류
- Code(.text)
- Data
- Heap
- Stack
- !!! 초기화된 전역변수는 Data에 존재
- !!! 초기화되지 않은 전역변수는 Data에 존재

> extern 
- 다른 파일에 해당 변수(혹은 함수가) 존재 할 것이라고 가정을 주는 선언

> static
- 소멸되지 않고 상주함(프로그램 종료 시점까지 상주함)
- 다른 블록에서 사용할 수 없다 (함수의 경우)

> 연산자에서 
- 간접 참조 연산자 [ * ,에스크리터 ] : 메모리상의 주소에 접근해서 데이터를 읽거나 쓴다, 포인터에 대해서만 * 연산이 가능하다
- 레퍼런스 연산자 [ & ,엠피센드 ] : 메모리상에 변수가 위치하는 주소를 구하는 단항 연산자
- 배열참조 연산자 [  []  ] : 배열명은 포인터 상수이며, 포인터를 통해 간점 참조를 수행
- 함수호출 연산자 [  ()  ] : 함수의 주소로 Program Counter가 점프함
- 구조체 직접참조 연산자 [ . ] : Like as 변수명을 이용한 연산
- 구조체 간접참조 연산자 [ -> ] : Like as 포인터를 활용한 연산
### !!! 구조체 연산을 공부해야함 -> 70page
### !!! 포인터 배열, 배열 포인터 정리 후 정복
>포인터의 3가지 종류
- 포인터 변수
- 배열명
- 함수
> Short circuit 
- 논리 연산에 따라 코드가 사라지는 현상 -> 성능향상을 위해 의도적으로 설계된 요소
```c
int num = 100;
int result = 0;
result = ( num < 0 ) && (코드가 실행되지 않는 영역)
result = ( num > 0 ) || (코드가 실행되지 않는 영역)
```
- Short circuit 을 활용하여 Bad Case와 Good Case ->> 75,76 page
>비트 연산자의 활용
```c
 REG = REG |= 0x01 << 5; // Bit SET

 REG = REG &= ~(0x01 << 5); // Bit Clear
```
> 콤퓨타공학자들이 성능향상을 위해 만든 3가지 요소
1. 캐시
2. DMA
3. 파이프라인
> 배열에서의 주의사항
- 참조 연산 분석 : 배열의 경계값을 넘어서서 작업은 어떤 결과를 초래할지 모른다 
- 잠재적으로 Runtime 에러나, 간헐적인 문제를 야기 할 수 있다
```c
int main (void){

    unsigned int var = 77;
    unsigned char arr[3] = {1,3,5};
    arr[3] = arr[0];

    puts("\n\nbefore");
    printf("arr[3] = %d \n",arr[3]);
    printf("var = %d \n",var) ;
	
    puts("\n\nafter");
    arr[3] = arr[0];
    printf("arr[3] = %d \n",arr[3]);
    printf("var = %d \n",var) ;
    
    return 0;
}
```
결과 : 위 테스트 코드를 컴파일시, 사용자마다 1 혹은 77이 다르게 나온다. 
- 위 코드를 통해서 C언어는(컴파일러는) 배열의 경계(바운더리)를 검사 해 주지 않는다 따라서 사용자가 배열을 사용할때는 인덱스가 0 부터 시작한다는 것을 꼭 명심하여야 한다.

## !!! 추가로 공부 해야 할 부분 : 한글의 표시 방식
> strcat 함수 소스코드 분석
```C
//char * strcpy ( char * dest, const char * source ); 문자열을 복사하는 함수
//문자열을 복사한 후 표준 출력 스트림에 출력
 
#pragma warning(disable:4996)
#include <string.h>
#include <stdio.h>
 
char *ehstrcpy(char *dest, const char *source)
{
    char *old_dest = dest;//원래 dest를 기억
    for (; *dest = *source; dest++, source++);//거짓인 문자를 복사할 때까지 반복
    return old_dest;
}
int main (void)
{
    char *src = "hello world";    
    char name[50] = "abc";
    char name2[50] = "abc";
    
    printf("<strcpy 이용> name: %s \n",strcpy(name,src));
    printf("<ehstrcpy 이용>name: %s \n", ehstrcpy(name, src));
    return 0;
}
```
출처 : Link (언제나 휴일님 블로그)  Link ( http://ehpub.co.kr/strcpy-%ED%95%A8%EC%88%98/ )


> volitaile 의미 (2가지)
- 캐쉬메모리에서 값을 가져오지마라, 주소에 직접 접근 해라
- 컴파일러 최적화 제한 명령어


# =============포인터에 관하여=============
> 해마책이 좋은 이유 : 인터페이스를 설명하고 메인을 짜넣게 함
- Ex) strcat ,


> 포인터 3형제 : 이중포인터, 배열포인터, 포인터배열
### 

> 함수 포인터
- 주소를 저장하면 포인터, 배열의 주소를 저장하면 배열포인터, 함수의 주소를 저장하면 함수포인터가 된다.
- 함수의 이름은 원래 포인터(주소 값)
- 함수의 이름이 주소임을 확인하기 위해서는 임베디드 기준 xx.map파일을 확인 해 보면 된다 
- (여담) 프로그램 카운터 PC는 다음에 실행할 명령의 주소임.
- 함수 호출 시 함수의 포인터(주소)로 프로그램 카운터가 이동하여 명령어를 수행함


> 콜백
- 함수를 Call 하는 방향이 반대라는 개념, 함수포인터로 함수를 대신 호출하는 방식
- 디바이스 드라이버에 많이 사용됨


## 배열의 주소에 관하여 - 같지만 다른 표현방식

## code

```C
int arr[5];

printf("%x \n",ary);//--------1

printf("%x \n",&ary[0]);//----2

printf("%x \n",ary+1);//------3

printf("%x \n",&ary + 1);//---4

```



