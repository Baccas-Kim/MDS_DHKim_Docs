# 개발환경 셋팅
  * 임베디드 소프트웨어는 개발환경 셋팅이 30% 변수가 많다 - 보드, 케이블, vmware 등등의 소프트웨어.. usb장치들(컴퓨터의 특성을 많이 타는 디바이스)

  #
  ## 리눅스 호스트(개발환경) 설정
 
  * sudo subl /etc/udev/rules.d/70-persistent-net.rules
    ```
    # This file was automatically generated by the /lib/udev/write_net_rules
    # program, run by the persistent-net-generator.rules rules file.
    #
    # You can modify it, as long as you keep each rule on a single
    # line, and change only the value of the NAME= key.
    # USB device 0x:0x (asix)
    SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="00:0e:c6:8f:9c:92", ATTR{dev_id}=="0x0", ATTR{type}=="1", KERNEL=="eth*", NAME="eth1"
    ```
  * 가상머신(리눅스 머신)에서 할일들
  * 윈도우즈에서 COM1, COM2... 리눅스에서는 ttys1, ttys2
  * 확인 명령어
    ```
    tail /var/log/kern.log
    ```
  * 확인결과
    ```
    user@linux:~$ tail /var/log/kern.log
    Jun  9 18:51:29 linux kernel: [  625.029179] asix 1-1:1.0 eth1: link up, 100Mbps, full-duplex, lpa 0x41E1
    Jun  9 18:51:34 linux kernel: [  629.596213] asix 1-1:1.0 eth1: link up, 100Mbps, full-duplex, lpa 0x41E1
    Jun  9 18:51:40 linux kernel: [  635.447277] asix 1-1:1.0 eth1: link up, 100Mbps, full-duplex, lpa 0x41E1
    Jun  9 18:51:44 linux kernel: [  639.949461] asix 1-1:1.0 eth1: link up, 100Mbps, full-duplex, lpa 0x41E1
    Jun  9 18:51:55 linux kernel: [  651.166051] asix 1-1:1.0 eth1: link up, 100Mbps, full-duplex, lpa 0x41E1
    Jun  9 18:57:40 linux kernel: [  995.890658] asix 1-1:1.0 eth1: link up, 100Mbps, full-duplex, lpa 0x41E1
    Jun  9 19:02:31 linux kernel: [ 1287.134139] asix 1-1:1.0 eth1: link up, 100Mbps, full-duplex, lpa 0x41E1
    Jun  9 19:15:45 linux kernel: [ 2080.535876] usb 3-2.1: USB disconnect, device number 5
    Jun  9 19:51:43 linux kernel: [ 4238.332882] asix 1-1:1.0 eth1: link up, 100Mbps, full-duplex, lpa 0x41E1
    Jun  9 19:51:45 linux kernel: [ 4240.679531] asix 1-1:1.0 eth1: link up, 100Mbps, full-duplex, lpa 0x41E1
    user@linux:~$ 

    ```

  * 리눅스에서의 복붙 : shift 더 붙이기
  * tftp 설정파일 확인 명령어 : 
    ```
    cat /etc/xinetd.d/tftp
    ```
  * 확인결과
    ```
    user@linux:~$ cat /etc/xinetd.d/tftp
    service tftp
    {
    protocol        = udp
    port            = 69
    socket_type     = dgram
    wait            = yes
    user            = nobody
    server          = /usr/sbin/in.tftpd
    server_args     = -s /tftpboot
    disable         = no
    }
    ```
  * ip설정
    ```
    cat /etc/network/interfaces
    ```
    ```
    NAT : 가상 라우터 ip 부족 문제를 해결할 수 있다.
    -sudo ifdown eth0 && sudo ifup eth0
    ```




  #
  ## MDS2450 보드 명령어
  * MDS2450 보드에서 할일 - 부트 커맨드 설정
    ```
    setenv 
    bootdelay 1;
    setenv bootcmd 'tftp 30000000 MDS2450.bin;go 30000000';
    set serverip 192.168.0.2;
    set ipaddr 192.168.0.3;
    saveenv

    ```
  * 명령어 종류
        * printenv
        * setenv

    
  * 타겟환경에서 할일들
    * 크로스 컴파일
    ```
    1. get : 보드로 파일을 가져오는것 -> 서버IP를 통해 가져오는것
    2. put : 
    3. 파일을 가져와서 메모리에 저장, 메모리의 주소 0x30000000 로 이동(16진수 수를 의미 함)
    4. go 명령어 : 파일의 실행, 펌웨어면 펌웨어가 동작하고, 리눅스 커널이라면 커널이 부팅됨.
    ```


  * 1일차 오전 수업내용 정리 정리
    1. 가상 리눅스 복잡하고 혼란스러우니까 네이티브 써라
    2. 일단 핫플러그드 디바이스는 사용하기전에 체크됨 확인
    3. 서비스의 작동을 위해서는 환경파일 -> ls /etc 명령어로 확인
        ex)  cat /etc/network/interfaces - 네트워크 디바이스,  cat /etc/xinetd.d/tftp -tftp 디바이스

 * 서브라임
  1. subl에서 tools -> bulid system -> new bulid system 
   ```shell
   {
	 "shell_cmd": "make clean && make"
   }

   ```
  
 # LED 장치 연습

  ```c
    void Led_Port_Init(void)
    {	
      /* 
      * LED On : Active Low 
      * Initialize GPGDAT[7:4] : high
      * Setup GPGCON[15:8] : 01-> GPG7~4 Output mode
      * GPGUP pull up function disable
      * 
      */
      /* YOUR CODE HERE */  
      *GPGCON = (*GPGCON &~ (0xf<<8))|(0x5<<8);
      *GPGDAT = (*GPGDAT &~ 0x3<<4);
    }

    void Led_Display(int data)
    {
      /* 
      * LED On : Active high 
        * LED Off: Active low
      * GPGDAT[7:4]
      */
      /* YOUR CODE HERE */  
      data = data&15;
      rGPGDAT = (rGPGDAT &~ (0xf<<4))|(data<<4);
    }

    /*
    #define rGPGCON    (*(volatile unsigned *)0x56000060)	//Port G control
    #define rGPGDAT    (*(volatile unsigned *)0x56000064)	//Port G data

    */
  ```
  * 2진수 to 16진수 변환표 암기(프로그래머에게 숨쉬는것과 같은 빈도 !!! 중요하다)


  * alias  설정
    ```s
    gedit .bashrc
    #show more ls aliases
    #alias ||="ls
    ```
    * 혹은
    ```s    
    alias pbcopy='xclip -selection clipboard'
    alias pbpaste='xclip -selection clipboard -o'
    alias m='minicom -w -D/dev/ttyS1'
    alias h='history'
    ```
 # 이번주 학습 목표
  * 이번주 학습 목표
    1. LCD
    2. 오디오 
    3. I/O (주변장치, 페리페럴)
  * 다음주  ARM 프로세서

 # RTOS서적에서 정리할 내용
   1. bashrc - 34p
   2. gedit/vim - 46p
   3. boot mode - 132p
   4. rs-232 - 200p
   5. U-boot - 161p

 # H/W에서 S/W로 이어지는 과정에 대한 학습
  1. 회로도 검색
  2. 회로도볼때는 adobe pdf뷰어를 사용
  3. Edit -> Preference 클릭하여 환경설정( 단축키 : ctrl+k )
  4. General 탭 -> 첫번째 항목인 Use single-key accelerators to access tools 항목 체크
  5. 위 4번의 설정은 H, v키를 통해 Mouse Mode 변경하여 업무 생산성 향상에 도움이 됨

 # 레지스터를 매핑하는 관용적 표현 
 ```c
  //레지스터 매핑 코드
  #define r_sample (*(volatile unsigned int*)0x56000064)
 
  //코드에서의 사용
  r_sample |= r_sample(0xf<<8)
 ```
 * 코드분석
   1. #define 사용 이유 : 전처리기를 활용하여, 컴파일타임 처리 (속도 향상)
   2. volatile 키워드 : 캐쉬가 아닌 레지스터(메모리)에 직접 접근하여 값을 새로 가져오는것을 명시하는 키워드 -> 컴파일러의 최적화에 의해 발생할 수 있는 논리적 에러를 사전에 방지하는 기능
   3. unsigned int 키워드 : 32Bit MCU(혹은 MPU)의 레지스터는 32비트 연산이 최적의 정보단위 이므로 (8bit MCU의 경우는 unsigned char 형 사용 추천, ex-Atmega128, 8051..)
   4. *(X*) 이유 ★★ -> ((*(volatile unsigned int *)0x56000064))->> 0x~의 값이 주소를 나타내는 상수이며(레지스터의 주소), 주소가 바라보는곳이 레지스터의 위치임. 레지스터 연산 시 주소가 담고 있는 값을 직접 접근하기 위해서 *기호(아스테리스크) 사용 함
   * 만족스럽지 못한 설명임 추후 수정예정 -> 19.06.10
 * 리눅스를 잘하기 위해 필수불가결한 요소(꼭 배워야 함!) : 쉘 프로그래밍
   1. 예시
    ```S
     make clean && make
     make clean; make
    ```
    * 위 두가지 항목은 다르다! 정상상태의 경우 결과물은 같다!
    * make clean && make : make clean이 성공해야만 make명령을 시도한다.
    * make clean; make : make clean의 성공여부와 상관 없이 make 명령을 시도한다.
   2. 쉘의 문법이 가져오는 생산성의 향상 예시
      - if 당신이 폴더 100개를 생성해야할때
      - 쉘 문법을 모른다면 노가다
      - 쉘을 사용하는 경우
      ```s
        mkdir A{1...100}
      ```
   3. 쉘이 어려운 이유
     - 스크립트이다. 쉘스크립트.. 고로 컴파일이 없으므로 런타임시에 에러를 확인할 수 있다.
     -동일한 스크립트 타입의 언어인 자바스크립트, 타입스크립트, 파이썬의 경우 어려운 이유는 동적실행 시 에러처리 뿐 아니라, 많은 패키지들을 가져다 쓰기에 어렵다.
     - 동일하게 쉘 스크립트 또한 약 1100개 이상의 리눅스 명령어를 모두 외우고 활용하는것은 많은 시간이 소요된다.   

   4. 결론 : 쉘을 배우자, (시작하는 순간 판도라의 상자가 열린것이다)

 * 짤막상식
   1. Refreash가 필요한 기기기는? EERPOM/SDRAM/NAND FLASH/SRAM
   2. Data Processing 명령에서 Opprand2가 immediate 상수로 사용 가능한 상수는?
   3. 메모리 맵 방식에 대한 설명으로 틀린 것은?? 
      - 메모리의 일부를 입출력장치에 할당
      - 메모리 관련 명령인 로드와 스토어 기능을 통해 장치에 엑세스 한다
      - 입출력 장치에 할당 된 주소영역은 캐셔블 하게 설정된다.
      - 입출력 자이에 사용되는 변수는 volatile키워드를 달아 선언한다.


   * 당신이 임베디드 프로그래밍(뿐만 아니라 리눅스 고수가 되기 위해)에 전문성을 가지기 위해서 필요한것 : 16진수 10진수 2진수 변환 표 암기!!
      1. 인간은 직관적임을 추구하는 동물이기에 암기가 필요하다.
      2. 필요성에 대한 근거로 리눅스 커널 소스코드 공부 추천
      3. 구구단의 필요성, 공기중 산소와 물의 필요성만큼이나 중요한 사항임
   |<---->|뭐야 표가 안써지자너  

깃허브 업로드 안됨 테스트 


# 2일차 
  ## 1. 학습내용 및 목표
  1. ARM 프로세서의 내부구조 간단히
     * 클럭 중 - AMBA버스 : pclk :66MHz
  2. UART 페리페럴의 클럭에 관하여 : PCLK 클럭 활용함 
  3. 레지스터 설정   
     1. 레지스터 설정 - UART 포트 설정 : GPHCON
     2. 레지스터 설정 - FIFO 기능 : UFCON1 -> 사용하지 않음
     3. 레지스터 설정 - 보레이트 설정 : UBRDIV1 
  4. 통신이야기 (From공대)
     1. UART의 필요성
     2. RS-232와  UART의 관계
     3. RS-232,422,485 차이점 
     4. UART와  USART : 동기통신과 비동기통신
     5. 다른 종류의 통신들(SPI, I2C, UART, USART, USB)
     6. OS별 개행문자 차이
     7. ASCII와 바이너리에 대하여
     8. 통신속도(Bps, baud rate)
     9. 동기통신과 비동기 통신의 차이에 관하여


  ## 2. 구현 해야 할 코드의 헤더 정의(표준 API)
  * BSP(보드를 쉽게 사용할 수 있는 코드 정의를 위해)제공을위해 만들어야 할 몇가지 함수가 정의되어있다.
  * 상황에따라 필요없는 함수는 생략해도 된다.
  * 또한 C표준 함수를 호출할수 있는 경우 atio()와 strlen() 은 구현하지 않아도 된다.
  ```h
  // Uart.h 파일에 들어갈 내용 내용
  void Uart_Init(int baud);
  void Uart_Printf(const char *fmt,...);
  void Uart_Send_String(char *pt);
  void Uart_Send_Byte(int data);
  void Uart_TxEmpty(int ch);
  char Uart_GetCh(void);
  char Uart_Get_Pressed(void);
  char Uart_GetKey(void);
  int Uart_GetString(char *string, int leng);
  int Uart_GetIntNum(void);
  int atoi(char *str);
  int strlen(const char *str);
  ```
  * 임베디드에서 구연해야 할 C 표준함수
  ```c
  // 임베디드에서 구연해야 할 C 표준함수
  int atoi(char *str);
  int strlen(const char *str);
  // A simple atoi() function
  int atoi(char *str)
  {
      int res = 0;  // Initialize result
      int sign = 1;  // Initialize sign as positive
      int i = 0;  // Initialize index of first digit
      
      // If number is negative, then update sign
      if (str[0] == '-')
      {
          sign = -1;  
          i++;  // Also update index of first digit
      }
      
      // Iterate through all digits and update the result
      for (; str[i] != '\0'; ++i)
          res = res*10 + str[i] - '0';
    
      // Return result with sign
      return sign*res;
  }

  int strlen(const char *str)
  {
          const char *s;

          for (s = str; *s; ++s)
                  ;
          return (s - str);
  }
  ```

### 3. Uart_Init 함수의 구현
  * Uart 초기화 하는 코드는 아래처럼 구현 후 함수로 묶어 줄 수 있다.
  ```c
  void Uart_Init(int baud)
  {
      #define GPHCON (*(unsigned int *))0x56000070
    int pclk;
    pclk = PCLK;

    // PORT GPIO initial( rGPHCON )
    //GPHCON
    rGPHCON = rGPHCON &~ (0xF<<4)|(0xA<<4);

    /* YOUR CODE HERE */  
    rUFCON1 = 0x0;
    rUMCON1 = 0x0;

    /* Line Control(Normal mode, No parity, One stop bit, 8bit Word length */
    rULCON1 = 0x3;

    /* Transmit & Receive Mode is polling mode  */
    rUCON1  = (1<<2)|(1);

    /* Baud rate 설정  */		
    rUBRDIV1= ((unsigned int)(PCLK/16./baud+0.5)-1 );
  }
  ```
  * 위의 코드에서 GPHCON  
  ![GPHCON](..\img\20190611-no014) 
  
  ```c
  rGPHCON = rGPHCON &~ (0xF<<4)|(0xA<<4);
  ```




  * 여기서 삼성프로세서 (S3c2450)만의 독특한 코드가 나와서 따로 다시 적어봤다.
  * rUBRDIV1 라는 레지스터를 사용해서 Bps(baud rate)를 설정한다.
  ```c
  rUBRDIV1 = ((unsigned int)(PCLK/16./baud+0.5)-1 );
  //ex) baudrate = 115200 이라면 그대로 적으면 된다.
  ```
  

  ## 4. Init이 아닌 다른 UART 함수의 구현체 
  ```c

  void Uart_Printf(const char *fmt,...)
  {
      va_list ap;
      char string[256];

      va_start(ap,fmt);
      vsprintf(string,fmt,ap);
      Uart_Send_String(string);
      va_end(ap);
  }

  void Uart_Send_String(char *pt)
  {
      while((*pt)!='\0')
      {
          Uart_Send_Byte(*pt);
          pt++;
      }
  }

  void Uart_Send_Byte(int data)
  {
      if(data=='\n')
      {
          while(!(rUTRSTAT1 & 0x2));
          WrUTXH1('\r');
      }

      while(!(rUTRSTAT1 & 0x2));	
      WrUTXH1(data);
      //#define WrUTXH1(ch) (*(volatile unsigned char *)0x50004023)=(unsigned char)(ch)
  }

  char Uart_GetChar(void)
  {
      /* UTRSTAT1의 값을 확인하여 문자열 입력   */	
      /* YOUR CODE HERE */  
      while(!(rUTRSTAT1 & 0x1));
          return RdURXH1();
      //#define RdURXH1()   (*(volatile unsigned char *)0x50004027)
  }
  ```
  * miniterm 종료시 : 모든 리눅스 프로그램 종료는 Q -> ctrl+d -> ctrl+q or z
 
  * 레지스터란 인간이 SW적으로 하드웨어를 제어하기 위해 존재하는 것
 
  ## 5. 통신이야기 (From공대)
  1. UART의 필요성
      * 키보드와 모니터 없이 하드웨어(MCU/MPU)와 데이터를 주고받을수 있는 사실상의 표준 입출력 시스템
  2. RS-232와  UART의 관계
      * 차이는 통신 전압의 차이(통신레벨)
      * UART는 MCU에서 직접 드라이브 되는 로직레벨(5V혹은 3.3V)의 직렬통신 신호
      * RS-232는 장거리 전송을 위해 12V로 전압 레벨이 올라간 직렬통신 신호
      * UART -> RS232, RS232 -> UART 를 위해서는 Transiver 필요함 
      * Transiver는 역할 기준의 명칭이며, 해당 기능을 제공하는 반도체 소자(IC, 제품명으로는 MAX-232)가 필요하다. 혹 422이나 485 통신을 원한다면 해당 기능에 맞는 Transiver(반도체 소자)가 필요하다.
   1. RS-232,422,485 차이점 
      * 직렬통신의 3가지 종류 :  RS-232, 422, 485 각각의 특징
      * RS-232 : 일반적(저렴하다), 근거리 통신규약
      * RS-422 : 차동방식 원거리 고속 통신
      * RS-485 : Multi-drop(1:N통신) 구성 지원 half-duflex
   2. UART와  USART 그리고 동기통신과 비동기통신
      *  UART : Ansync 직렬통신
      *  USART : sync 직렬통신 -> 거의 사용되지 않음.
      *  동기통신 : Data + Clock , 클럭이 별도로 존재하는 통신(I2C) : 수신측과 송신측이 전선만 연결해도 통신이 됨(단 I2C통신은 오픈드레인 구조의 경우 풀업저항이 필요)
      *  비동기 통신 : Tx + Rx , 클럭이 별도로 존재하지 않는 통신(UART) : 수신측과 송신측 모두 상대방의 통신속도를 미리 알고 있다는 전제 하에 데이터를 주고받음.
         *  동기라는 의미는 클럭이 동기화되어있다. 비동기는 클럭라인이 비동기(연결되지 않았다) 라는 의미입니다.
   3. 다른 종류의 통신들(SPI, I2C, UART, USART, USB)
      * UART와 USART : 
      * SPI고속 단거리 통신으로 사용 주로 LCD등의 대량의 데이터를 처리하거나 영상정보를 송수신 하는 용도로 사용
      * I2C저속으로 데이터를 주고 받을 때 사용하며, 해당통신기능을 활용한 아두이노 모듈이 최근 많이 출시되고 있음 
      * PC 혹은 USB 호스트와의 연결을 위해 필요함. USB스텍이 무겁기 때문에(펌웨어의 크기가 커지기에) 낮은성능의 MCU에는 없는 경우도 많다.
   4. OS별 개행문자 차이
      * OS별 개행문자 차이 ->> 윈도우즈: "\r\n" , Unix계열(mac, Linux): "\r"
   5. ASCII와 바이너리에 대하여
      * binary의 경우 0x41 는 0x41
      * ASCII 의 경우에는 0x41은 문자 'A'  
   6. 통신속도(Bps, baud rate)
      * UART를 이용한 시리얼 통신 사실상의 표준은 : 115200 n 8 1
      * 115200 : baud rate
      * n : 흐름제어
      * 8 : 데이터 
      * 1 : 정지비트
   
#
##  Timer

  ```c

  void Timer_Init(void)
  {
    /* 
    * 	Timer0 Init 
    * Prescaler value : 255, dead zone length = 0
    * Divider value : 1/16, no DMA mode
    * New frequency : (PCLK/(Prescaler value+1))*Divider value = (66Mhz/(256))*(1/16)
    *				= 16.113Khz(16113Hz)
    */
    // target freq : 16.113khz ->> 	rTCFG0=255, rTCFG1=16
  /* TODO : Timer Clock Configure */
    rTCFG0 |= 0xff; //Bit set
    rTCFG1 |= 0xf;
    rTCFG1 &= ~(0xf<<2); 
    
    /* TCON설정 :Dead zone disable,  auto reload on, output inverter off
    *  manual update no operation, timer0 stop, TCNTB0=0, TCMPB0 =0
    */
    rTCON  = (0<<4)|(1<<3)|(0<<2)|(0<<1)|(0);
    rTCNTB0 = 0;
    rTCMPB0 = 0;
  
  }

  void Timer_Delay(int msec)
  {
    /*
    * 1) TCNTB0설정 : 넘겨받는 data의 단위는 msec이다.
    *                  따라서 msec가 그대로 TCNTB0값으로 설정될 수는 없다.
    * 2) manual update후에  timer0를 start시킨다. 
    * 	 note : The bit has to be cleared at next writing.
    * 3) TCNTO0값이 0이 될때까지 기다린다. 	
    */
  /* TODO : Timer Counter Setting */
    rTCNTB0 = 16.113 * msec;

    rTCON |= (1<<1)|(0);//manul updata
    rTCON &= ~(1<<1);//manul updata
    
    rTCON |= 1;	//trigger timer start
    
    while(rTCNTO0 != 0);// TCNTO0 : wait for Observation Registor -> read only
    
  }

  ```
  
