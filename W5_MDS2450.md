# 개발환경 셋팅
  * 임베디드 소프트웨어는 개발환경 셋팅이 30% 변수가 많다 - 보드, 케이블, vmware 등등의 소프트웨어.. usb장치들(컴퓨터의 특성을 많이 타는 디바이스)

  #
  ## 리눅스 호스트(개발환경) 설정
 
  * sudo subl /etc/udev/rules.d/70-persistent-net.rules
    ```
    # This file was automatically generated by the /lib/udev/write_net_rules
    # program, run by the persistent-net-generator.rules rules file.
    #
    # You can modify it, as long as you keep each rule on a single
    # line, and change only the value of the NAME= key.
    # USB device 0x:0x (asix)
    SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="00:0e:c6:8f:9c:92", ATTR{dev_id}=="0x0", ATTR{type}=="1", KERNEL=="eth*", NAME="eth1"
    ```
  * 가상머신(리눅스 머신)에서 할일들
  * 윈도우즈에서 COM1, COM2... 리눅스에서는 ttys1, ttys2
  * 확인 명령어
    ```
    tail /var/log/kern.log
    ```
  * 확인결과
    ```
    user@linux:~$ tail /var/log/kern.log
    Jun  9 18:51:29 linux kernel: [  625.029179] asix 1-1:1.0 eth1: link up, 100Mbps, full-duplex, lpa 0x41E1
    Jun  9 18:51:34 linux kernel: [  629.596213] asix 1-1:1.0 eth1: link up, 100Mbps, full-duplex, lpa 0x41E1
    Jun  9 18:51:40 linux kernel: [  635.447277] asix 1-1:1.0 eth1: link up, 100Mbps, full-duplex, lpa 0x41E1
    Jun  9 18:51:44 linux kernel: [  639.949461] asix 1-1:1.0 eth1: link up, 100Mbps, full-duplex, lpa 0x41E1
    Jun  9 18:51:55 linux kernel: [  651.166051] asix 1-1:1.0 eth1: link up, 100Mbps, full-duplex, lpa 0x41E1
    Jun  9 18:57:40 linux kernel: [  995.890658] asix 1-1:1.0 eth1: link up, 100Mbps, full-duplex, lpa 0x41E1
    Jun  9 19:02:31 linux kernel: [ 1287.134139] asix 1-1:1.0 eth1: link up, 100Mbps, full-duplex, lpa 0x41E1
    Jun  9 19:15:45 linux kernel: [ 2080.535876] usb 3-2.1: USB disconnect, device number 5
    Jun  9 19:51:43 linux kernel: [ 4238.332882] asix 1-1:1.0 eth1: link up, 100Mbps, full-duplex, lpa 0x41E1
    Jun  9 19:51:45 linux kernel: [ 4240.679531] asix 1-1:1.0 eth1: link up, 100Mbps, full-duplex, lpa 0x41E1
    user@linux:~$ 

    ```

  * 리눅스에서의 복붙 : shift 더 붙이기
  * tftp 설정파일 확인 명령어 : 
    ```
    cat /etc/xinetd.d/tftp
    ```
  * 확인결과
    ```
    user@linux:~$ cat /etc/xinetd.d/tftp
    service tftp
    {
    protocol        = udp
    port            = 69
    socket_type     = dgram
    wait            = yes
    user            = nobody
    server          = /usr/sbin/in.tftpd
    server_args     = -s /tftpboot
    disable         = no
    }
    ```
  * ip설정
    ```
    cat /etc/network/interfaces
    ```
    ```
    NAT : 가상 라우터 ip 부족 문제를 해결할 수 있다.
    -sudo ifdown eth0 && sudo ifup eth0
    ```




  #
  ## MDS2450 보드 명령어
  * MDS2450 보드에서 할일 - 부트 커맨드 설정
    ```
    setenv 
    bootdelay 1;
    setenv bootcmd 'tftp 30000000 MDS2450.bin;go 30000000';
    set serverip 192.168.0.2;
    set ipaddr 192.168.0.3;
    saveenv

    ```
  * 명령어 종류
        * printenv
        * setenv

    
  * 타겟환경에서 할일들
    * 크로스 컴파일
    ```
    1. get : 보드로 파일을 가져오는것 -> 서버IP를 통해 가져오는것
    2. put : 
    3. 파일을 가져와서 메모리에 저장, 메모리의 주소 0x30000000 로 이동(16진수 수를 의미 함)
    4. go 명령어 : 파일의 실행, 펌웨어면 펌웨어가 동작하고, 리눅스 커널이라면 커널이 부팅됨.
    ```


  * 1일차 오전 수업내용 정리 정리
    1. 가상 리눅스 복잡하고 혼란스러우니까 네이티브 써라
    2. 일단 핫플러그드 디바이스는 사용하기전에 체크됨 확인
    3. 서비스의 작동을 위해서는 환경파일 -> ls /etc 명령어로 확인
        ex)  cat /etc/network/interfaces - 네트워크 디바이스,  cat /etc/xinetd.d/tftp -tftp 디바이스

 * 서브라임
  1. subl에서 tools -> bulid system -> new bulid system 
   ```shell
   {
	 "shell_cmd": "make clean && make"
   }

   ```
  
 # LED 장치 연습

  ```c
    void Led_Port_Init(void)
    {	
      /* 
      * LED On : Active Low 
      * Initialize GPGDAT[7:4] : high
      * Setup GPGCON[15:8] : 01-> GPG7~4 Output mode
      * GPGUP pull up function disable
      * 
      */
      /* YOUR CODE HERE */  
      *GPGCON = (*GPGCON &~ (0xf<<8))|(0x5<<8);
      *GPGDAT = (*GPGDAT &~ 0x3<<4);
    }

    void Led_Display(int data)
    {
      /* 
      * LED On : Active high 
        * LED Off: Active low
      * GPGDAT[7:4]
      */
      /* YOUR CODE HERE */  
      data = data&15;
      rGPGDAT = (rGPGDAT &~ (0xf<<4))|(data<<4);
    }

    /*
    #define rGPGCON    (*(volatile unsigned *)0x56000060)	//Port G control
    #define rGPGDAT    (*(volatile unsigned *)0x56000064)	//Port G data

    */
  ```
  * 2진수 to 16진수 변환표 암기(프로그래머에게 숨쉬는것과 같은 빈도 !!! 중요하다)


  * alias  설정
    ```s
    gedit .bashrc
    #show more ls aliases
    #alias ||="ls
    ```
    * 혹은
    ```s    
    alias pbcopy='xclip -selection clipboard'
    alias pbpaste='xclip -selection clipboard -o'
    alias m='minicom -w -D/dev/ttyS1'
    alias h='history'
    ```
 # 이번주 학습 목표
  * 이번주 학습 목표
    1. LCD
    2. 오디오 
    3. I/O (주변장치, 페리페럴)
  * 다음주  ARM 프로세서

 # RTOS서적에서 정리할 내용
   1. bashrc - 34p
   2. gedit/vim - 46p
   3. boot mode - 132p
   4. rs-232 - 200p
   5. U-boot - 161p

 # H/W에서 S/W로 이어지는 과정에 대한 학습
  1. 회로도 검색
  2. 회로도볼때는 adobe pdf뷰어를 사용
  3. Edit -> Preference 클릭하여 환경설정( 단축키 : ctrl+k )
  4. General 탭 -> 첫번째 항목인 Use single-key accelerators to access tools 항목 체크
  5. 위 4번의 설정은 H, v키를 통해 Mouse Mode 변경하여 업무 생산성 향상에 도움이 됨

 # 레지스터를 매핑하는 관용적 표현 
 ```c
  //레지스터 매핑 코드
  #define r_sample (*(volatile unsigned int*)0x56000064)
 
  //코드에서의 사용
  r_sample |= r_sample(0xf<<8)
 ```
 * 코드분석
   1. #define 사용 이유 : 전처리기를 활용하여, 컴파일타임 처리 (속도 향상)
   2. volatile 키워드 : 캐쉬가 아닌 레지스터(메모리)에 직접 접근하여 값을 새로 가져오는것을 명시하는 키워드 -> 컴파일러의 최적화에 의해 발생할 수 있는 논리적 에러를 사전에 방지하는 기능
   3. unsigned int 키워드 : 32Bit MCU(혹은 MPU)의 레지스터는 32비트 연산이 최적의 정보단위 이므로 (8bit MCU의 경우는 unsigned char 형 사용 추천, ex-Atmega128, 8051..)
   4. *(X*) 이유 ★★ -> ((*(volatile unsigned int *)0x56000064))->> 0x~의 값이 주소를 나타내는 상수이며(레지스터의 주소), 주소가 바라보는곳이 레지스터의 위치임. 레지스터 연산 시 주소가 담고 있는 값을 직접 접근하기 위해서 *기호(아스테리스크) 사용 함
   * 만족스럽지 못한 설명임 추후 수정예정 -> 19.06.10
 * 리눅스를 잘하기 위해 필수불가결한 요소(꼭 배워야 함!) : 쉘 프로그래밍
   1. 예시
    ```S
     make clean && make
     make clean; make
    ```
    * 위 두가지 항목은 다르다! 정상상태의 경우 결과물은 같다!
    * make clean && make : make clean이 성공해야만 make명령을 시도한다.
    * make clean; make : make clean의 성공여부와 상관 없이 make 명령을 시도한다.
   2. 쉘의 문법이 가져오는 생산성의 향상 예시
      - if 당신이 폴더 100개를 생성해야할때
      - 쉘 문법을 모른다면 노가다
      - 쉘을 사용하는 경우
      ```s
        mkdir A{1...100}
      ```
   3. 쉘이 어려운 이유
     - 스크립트이다. 쉘스크립트.. 고로 컴파일이 없으므로 런타임시에 에러를 확인할 수 있다.
     -동일한 스크립트 타입의 언어인 자바스크립트, 타입스크립트, 파이썬의 경우 어려운 이유는 동적실행 시 에러처리 뿐 아니라, 많은 패키지들을 가져다 쓰기에 어렵다.
     - 동일하게 쉘 스크립트 또한 약 1100개 이상의 리눅스 명령어를 모두 외우고 활용하는것은 많은 시간이 소요된다.   

   4. 결론 : 쉘을 배우자, (시작하는 순간 판도라의 상자가 열린것이다)

 * 짤막상식
   1. Refreash가 필요한 기기기는? EERPOM/SDRAM/NAND FLASH/SRAM
   2. Data Processing 명령에서 Opprand2가 immediate 상수로 사용 가능한 상수는?
   3. 메모리 맵 방식에 대한 설명으로 틀린 것은?? 
      - 메모리의 일부를 입출력장치에 할당
      - 메모리 관련 명령인 로드와 스토어 기능을 통해 장치에 엑세스 한다
      - 입출력 장치에 할당 된 주소영역은 캐셔블 하게 설정된다.
      - 입출력 자이에 사용되는 변수는 volatile키워드를 달아 선언한다.


   * 당신이 임베디드 프로그래밍(뿐만 아니라 리눅스 고수가 되기 위해)에 전문성을 가지기 위해서 필요한것 : 16진수 10진수 2진수 변환 표 암기!!
      1. 인간은 직관적임을 추구하는 동물이기에 암기가 필요하다.
      2. 필요성에 대한 근거로 리눅스 커널 소스코드 공부 추천
      3. 구구단의 필요성, 공기중 산소와 물의 필요성만큼이나 중요한 사항임
   |<---->|뭐야 표가 안써지자너  



